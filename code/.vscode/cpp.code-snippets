
{
	"template":{
		"prefix": "tmp",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <atcoder/all>",
"using namespace std;",
"using namespace atcoder;",
"using ll = long long;",
"using ull = unsigned long long;",
"const double pi = acos(-1);",
"#define OVERLOAD_REP(_1, _2, _3, name, ...) name",
"#define REP1(i, n) for (auto i = std::decay_t<decltype(n)>{}; (i) != (n); ++(i))",
"#define REP2(i, l, r) for (auto i = (l); (i) != (r); ++(i))",
"#define rep(...) OVERLOAD_REP(__VA_ARGS__, REP2, REP1)(__VA_ARGS__)",
"#define all(p) (p).begin(), (p).end()",
"#define exists(c, e) ((c).find(e) != (c).end())",
"template<class T> bool chmin(T& a,T b) { if(a > b){a = b; return true;} return false; }",
"template<class T> bool chmax(T& a,T b) { if(a < b){a = b; return true;} return false; }",
"template<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }",
"template<class T>constexpr T HINF() { return INF<T>() / 2; }",
"const int dy[] = {1, 0, -1, 0};",
"const int dx[] = {0, 1, 0, -1};",
"",
"struct INIT{",
 "INIT(){",
  "std::ios::sync_with_stdio(false);",
  "std::cin.tie(0);",
  "cout << fixed << setprecision(20);",
 "}",
"}INIT;"
		],
		"description": "atcoderのテンプレート"
	},

	"greatest common divisor": {
		"prefix": "gcd",
		"body": [
			"ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a;}"
		],
		"description": "最大公約数"
	},

	
	"least common multiple": {
		"prefix": "lcm",
		"body": [
			"ll lcm(ll a, ll b) { return a / gcd(a, b) * b;}"
		],
		"description": "最小公倍数"
	},



	"primality test":{
		"prefix": "isPrime",
		"body": [
			"bool isPrime(int x){",
			"   int i;",
			"   if(x < 2)return 0;",
			"   else if(x == 2) return 1;",
			"   if(x%2 == 0) return 0;",
			"   for(i = 3; i*i <= x; i += 2) if(x%i == 0) return 0;",
			"   return 1;",
			"}"
		],
		"description": "素数かどうかを判定する。素数なら１を素数でないなら０を返す"
	},
	
	"digit sum":{
		"prefix": "digsum",
		"body": [
			"ll digsum(ll n) {",
			"    int res = 0;",
			"    while(n > 0) {",	
			"       res += n%10;",
			"       n /= 10;",
			"    }",
			"return res;",
			"}"
		],
		"description": "各桁の和を返す"
		
	},

	"string count":{
		"prefix": "stringcount",
		"body": [
			"ll stringcount(string s, char c) {",
			"    return count(s.cbegin(), s.cend(), c)",
			"}"
		],
		"description": "文字列中に存在する特定の文字の個数を数える"
	},

	"bfs": {
        "prefix": "bfs",
        "body": [
            "struct BFS {",
            "    Graph G;",
            "    vector<int> dist;",
            "    vector<int> color;",
            "    BFS(const Graph& G) : G(G), dist(G.size(), -1), color(G.size(), -1) {}",
            "",
            "    // 単一始点最短経路",
            "    void shortest_path(int start) {",
            "        queue<int> q;",
            "        dist[start] = 0;",
            "        q.push(start);",
            "        while (!q.empty()) {",
            "            int v = q.front(); q.pop();",
            "            for (int nv : G[v]) {",
            "                if (dist[nv] == -1) {",
            "                    dist[nv] = dist[v] + 1;",
            "                    q.push(nv);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    // 到達可能なノードを取得",
            "    vector<int> reachable_nodes(int start) {",
            "        vector<int> reachable;",
            "        queue<int> q;",
            "        vector<bool> visited(G.size(), false);",
            "        q.push(start);",
            "        visited[start] = true;",
            "        while (!q.empty()) {",
            "            int v = q.front(); q.pop();",
            "            reachable.push_back(v);",
            "            for (int nv : G[v]) {",
            "                if (!visited[nv]) {",
            "                    visited[nv] = true;",
            "                    q.push(nv);",
            "                }",
            "            }",
            "        }",
            "        return reachable;",
            "    }",
            "",
            "    // トポロジカルソート（DAG判定）",
            "    vector<int> topological_sort() {",
            "        vector<int> in_degree(G.size(), 0);",
            "        for (auto& adj : G) {",
            "            for (int v : adj) in_degree[v]++;",
            "        }",
            "        queue<int> q;",
            "        vector<int> order;",
            "        rep(i, G.size()) if (in_degree[i] == 0) q.push(i);",
            "        while (!q.empty()) {",
            "            int v = q.front(); q.pop();",
            "            order.push_back(v);",
            "            for (int nv : G[v]) {",
            "                if (--in_degree[nv] == 0) q.push(nv);",
            "            }",
            "        }",
            "        if (order.size() != G.size()) return {}; // サイクルがある場合",
            "        return order;",
            "    }",
            "",
            "    // 木の直径の計算",
            "    int tree_diameter() {",
            "        auto bfs_farthest = [&](int start) {",
            "            vector<int> d(G.size(), -1);",
            "            queue<int> q;",
            "            q.push(start);",
            "            d[start] = 0;",
            "            int farthest = start;",
            "            while (!q.empty()) {",
            "                int v = q.front(); q.pop();",
            "                for (int nv : G[v]) {",
            "                    if (d[nv] == -1) {",
            "                        d[nv] = d[v] + 1;",
            "                        q.push(nv);",
            "                        if (d[nv] > d[farthest]) farthest = nv;",
            "                    }",
            "                }",
            "            }",
            "            return make_pair(farthest, d[farthest]);",
            "        };",
            "        int u = bfs_farthest(0).first;",
            "        return bfs_farthest(u).second;",
            "    }",
            "};"
        ],
        "description": ""
    },


	"deepth-first search":{
		"prefix": "DFS",
		"body": [
			"using Graph = vector<vector<int>>;",
			"vector<bool> seen;",
			"void dfs(const Graph &G, int v) {",
			"    seen[v] = true;",
			"    for (auto next_v : G[v]) {", 
			"        if (seen[next_v]) continue;",
			"        dfs(G, next_v);",
			"    }",
		"}"
		],
		"description":[
			"深さ優先探索",
			"vector<bool> seen はその時点での訪問した頂点を格納する配列"
		]
	},

	"Binary search":{
		"prefix": "BS",
		"body":[
			"int binary_search(int x){",
			"int ok = 1 //解が存在する値",
			"int ng = n; //解が存在しない値",
			"while(abs(ok - ng) > 1){",
			"    int mid = (ok + ng)/2;",
			"    if(solve(mid, x) ok = mid;",
			"    else ng = mid;",
			"}",
			"return ok;"
		],
		"description": [
			"二分探索"
			
		]
	},

	"modpow":{
		"prefix": "modpow",
		"body": [
			"ll modpow(ll a, ll b, ll m){",
			"    ll p = a, ans = 1;",
			"    for(int i = 0; i < 60; i++){",
			"        ll wari = (1ll << i);",
			"        if((b / wari) % 2 == 1){",
			"            ans = (ans * p) % m;",
			"        }",
			"        p = (p * p) % m;",
			"    }",
			"    return ans;",
			"}"
		],
		"description": [
			"aのb乗をmで割った余りを返す関数"
		]
	},

	"Basen to long":{
		"prefix": "basen number",
		"body": [
			"ll basen_to_long (string n, ll p){",
			"    ll ans = 0, x = 1, m = n.size();",
			"    for(int i = m-1; i >= 0; i--){",
			"        ans += 1LL * (n[i]-'0') * x;",
			"        x *= (ll)(p);",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "n進数を10進数に変換する関数"
	},

	"Long to Basen":{
		"prefix": "longtobasen",
		"body": [
			"string long_to_base9(ll n, ll p){",
			"    string ans;",
			"    while(n>0){",
			"        char c = {(n%p)+'0'};",
			"        ans = c + ans;",
			"        n /= p;",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "10進数をn進数に変換する関数"
	},

	"distance":{
		"prefix": "distance",
		"body": [
			"long double distance(ll ax, ll ay, ll bx, ll by){",
    		"    return sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by));",
			"}"
		],
		"description": "二次元座標の距離を求める関数"
	},

	"sieve":{
		"prefix": "sieve",
		"body": [
			"const int L = 4000000;",
			"vector<ll> primes;",
			"void sieve() {",
    		"    vector<bool> is_prime(L + 1, true);",
    		"    is_prime[0] = is_prime[1] = false;",
    		"    for (ll i = 2; i <= L; ++i) {",
        	"        if (is_prime[i]) {",
            "            primes.push_back(i);",
            "            for (ll j = (ll)i * i; j <= L; j += i) {",
            "               is_prime[j] = false;",
            "            }",
            "        }",
            "    }",
			"}"
		],
		"description": "エラトステネスの篩"
	},

	"my_compare":{
		"prefix":"my_compare",
		"body":[
			"bool my_compare(pair<int, int> a, pair<int, int> b) {",
			"    if(a.first != b.first){",
			"         return a.first > b.first;",
			"    }",
			"    return a.second < b.second;",
			"}"
		],
		"description":"sort(all(?), ココ)"
	},

	"power":{
		"prefix": "power",
		"body":[
			"ll power(ll a, ll b, ll m){",
			"    ll p = a;",
			"    ll res = 1;",
			"    for(int i = 0; i < 60; i++){",
			"        int wari = (1 << i);",
			"        if((b/wari)%2 == 1){",
			"            res = (res * p) % m;",
			"        }",
			"        p = (p * p) % m;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "aをb乗をmで割った余りを返す関数"
	},
	
	"union_find": {
        "prefix": "UnionFind",
        "body": [
            "struct UnionFind {",
            "    // core member",
            "    vector<int> par;",
            "",
            "    // constructor",
            "    UnionFind() { }",
            "    UnionFind(int n) : par(n, -1) { }",
            "    void init(int n) { par.assign(n, -1); }",
            "    ",
            "    // core methods",
            "    int root(int x) {",
            "        if (par[x] < 0) return x;",
            "        else return par[x] = root(par[x]);",
            "    }",
            "    ",
            "    bool same(int x, int y) {",
            "        return root(x) == root(y);",
            "    }",
            "    ",
            "    bool unite(int x, int y) {",
            "        x = root(x), y = root(y);",
            "        if (x == y) return false;",
            "        if (par[x] > par[y]) swap(x, y); // merge technique",
            "        par[x] += par[y];",
            "        par[y] = x;",
            "        return true;",
            "    }",
            "    ",
            "    int size(int x) {",
            "        return -par[root(x)];",
            "    }",
            "    ",
            "    // グループ構造の詳細を取得する関数",
            "    vector<vector<int>> groups() {",
            "        // member[v] := 要素 v をリーダーとするグループ",
            "        vector<vector<int>> member(par.size());",
            "        for (int v = 0; v < (int)par.size(); ++v) {",
            "            member[root(v)].push_back(v);",
            "        }",
            "        ",
            "        // 配列 member の空の部分を削除したものを作る",
            "        vector<vector<int>> res;",
            "        for (int v = 0; v < (int)par.size(); ++v) {",
            "            if (!member[v].empty()) res.push_back(member[v]);",
            "        }",
            "        return res;",
            "    }",
            "};",
        ],
        "description": ""
    },

	"dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "struct edge{",
            "    long long to;",
            "    long long cost;",
            "};",
            "using Graph = vector<vector<edge>>;",
            "using P = pair<long long, int>;",
            "/* dijkstra(G,s,dis,prev)",
            "    入力：グラフ G, 開始点 s, 距離を格納する dis, 最短経路の前の点を記録するprev",
            "    計算量：O(|E|log|V|)",
            "    副作用：dist, prevが書き換えられる",
            "*/",
            "void dijkstra(const Graph &G, int s, vector<long long> &dist, vector<int> &prev){",
            "    int n = G.size();",
            "    dist.resize(N, INF<ll>());",
			"    prev.resize(n, -1)",
            "    priority_queue<P, vector<P>, greater<P>> pq;",
            "    dist[s] = 0;",
            "    pq.emplace(dist[s], s);",
            "    while(!pq.empty()){",
            "        P p = pq.top(); pq.pop();",
            "        int v = p.second;",
            "        if(dist[v] < p.first) continue;",
            "        for(auto &e : G[v]){",
            "            if(dist[e.to] > dist[v] + e.cost){",
            "                dist[e.to] = dist[v] + e.cost;",
			"                prev[e.to] = v; //頂点vからe.toへ到達",
            "                pq.emplace(dist[e.to], e.to);",
            "            }",
            "        }",
            "    }",
            "}",
        ],
        "description": ""
    },

	"get_path": {
        "prefix": "get_path",
        "body": [
            "/* get_path(prev, t)",
            "    入力：dijkstra で得た prev, ゴール t",
            "    出力： t への最短路のパス",
            "*/",
            "vector<int> get_path(const vector<int> &prev, int t) {",
            "    vector<int> path;",
            "    for (int cur = t; cur != -1; cur = prev[cur]) {",
            "        path.push_back(cur);",
            "    }",
            "    reverse(path.begin(), path.end()); // 逆順なのでひっくり返す",
            "    return path;",
            "}",
        ],
        "description": ""
    },

    "Trie": {
        "prefix": "Trie",
        "body": [
            "/* Trie 木： 文字の種類(char_size)、int型で0に対応する文字(base)",
            "    insert(word): 単語 word を Trie 木に挿入する",
            "    search(word): 単語 word が Trie 木にあるか判定する",
            "    start_with(prefix):  prefix が一致する単語が Trie 木にあるか判定する",
            "    count(): 挿入した単語の数を返す",
            "    size(): Trie 木の頂点数を返す",
            "    計算量：insert, search ともに O(M)（Mは単語の長さ）",
            "*/",
            "template <int char_size, int base>",
            "struct Trie {",
            "    struct Node {            // 頂点を表す構造体",
            "        vector<int> next;    // 子の頂点番号を格納。存在しなければ-1",
            "        vector<int> accept;  // 末端がこの頂点になる単語の word_id を保存",
            "        int c;               // base からの間隔をint型で表現したもの",
            "        int common;          // いくつの単語がこの頂点を共有しているか",
            "        Node(int c_) : c(c_), common(0) {",
            "            next.assign(char_size, -1);",
            "        }",
            "    };",
            "",
            "    vector<Node> nodes;  // trie 木本体",
            "    int root;",
            "    Trie() : root(0) {",
            "        nodes.push_back(Node(root));",
            "    }",
            "",
            "    // 単語の挿入",
            "    void insert(const string &word, int word_id) {",
            "        int node_id = 0;",
            "        for (int i = 0; i < (int)word.size(); i++) {",
            "            int c = (int)(word[i] - base);",
            "            int &next_id = nodes[node_id].next[c];",
            "            if (next_id == -1) {  // 次の頂点が存在しなければ追加",
            "                next_id = (int)nodes.size();",
            "                nodes.push_back(Node(c));",
            "            }",
            "            ++nodes[node_id].common;",
            "            node_id = next_id;",
            "        }",
            "        ++nodes[node_id].common;",
            "        nodes[node_id].accept.push_back(word_id);",
            "    }",
            "    void insert(const string &word) {",
            "        insert(word, nodes[0].common);",
            "    }",
            "",
            "    // 単語とprefixの検索",
            "    bool search(const string &word, bool prefix = false) {",
            "        int node_id = 0;",
            "        for (int i = 0; i < (int)word.size(); i++) {",
            "            int c = (int)(word[i] - base);",
            "            int &next_id = nodes[node_id].next[c];",
            "            if (next_id == -1) {  // 次の頂点が存在しなければ終了",
            "                return false;",
            "            }",
            "            node_id = next_id;",
            "        }",
            "        return (prefix) ? true : nodes[node_id].accept.size() > 0;",
            "    }",
            "",
            "    // prefix を持つ単語が存在するかの検索",
            "    bool start_with(const string &prefix) {",
            "        return search(prefix, true);",
            "    }",
            "",
            "    // prefix を持つ単語が存在するかの検索",
            "    bool has_prefix(const string& word){",
            "        int node_id = 0;",
            "        for(int i = 0; i <(int)word.size(); i++){",
            "            if(!nodes[node_id].accept.empty()) return true;",
            "            int c = (int)(word[i] - base);",
            "            int &next_id = nodes[node_id].next[c];",
            "            if(next_id == -1){",
            "                return false;",
            "            }",
            "            node_id = next_id;",
            "        }",
            "        return !nodes[node_id].accept.empty();",
            "    }",
            "",
            "    // 挿入した単語の数",
            "    int count() const {",
            "        return (nodes[0].common);",
            "    }",
            "    // Trie木のノード数",
            "    int size() const {",
            "        return ((int)nodes.size());",
            "    }",
            "",
            "    // 指定したprefixを持つ単語の削除",
            "    int del(const string &prefix){",
            "        int node_id = 0;",
            "        for (int i = 0; i < (int)prefix.size(); i++) {",
            "            int c = (int)(prefix[i] - base);",
            "            int &next_id = nodes[node_id].next[c];",
            "            if (next_id == -1) {  // 次の頂点が存在しなければ終了",
            "                return 0;",
            "            }",
            "            node_id = next_id;",
            "        }",
            "",
            "        stack<int> st;",
            "        int accept_cnt = 0;",
            "        st.push(node_id);",
            "        while(!st.empty()){",
            "            int id = st.top();",
            "            st.pop();",
            "            accept_cnt += nodes[id].accept.size();",
            "            nodes[id].accept.clear();",
            "            for(int i = 0; i < char_size; i++){",
            "                if(nodes[id].next[i] != -1){",
            "                    st.push(nodes[id].next[i]);",
            "                }",
            "            }",
            "        }",
            "        return accept_cnt;",
            "    }",
            "",
            "    bool exist_prefix(const string &prefix){",
            "        int node_id = 0;",
            "        for (int i = 0; i < (int)prefix.size(); i++) {",
            "            int c = (int)(prefix[i] - base);",
            "            int &next_id = nodes[node_id].next[c];",
            "            if (next_id == -1) {  // 次の頂点が存在しなければ終了",
            "                return false;",
            "            }",
            "            node_id = next_id;",
            "            if(nodes[node_id].accept.size() > 0) return true;",
            "        }",
            "        return false;",
            "    }",
            "};",
        ],
        "description": ""
    },

}